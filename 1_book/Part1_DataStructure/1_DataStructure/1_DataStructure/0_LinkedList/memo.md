# 링크드 리스트(Linked List)
> 노드의 추가/삽입/삭제는 빠르나 <br>
> 특정 위치에 있는 노드를 찾는 연산은 느림

> 레코드의 추가/삽입/삭제가 잦고 조회는 드문 곳에 적합 <br>
> ㄴ 데이터베이스에서 조회해 온 레코드를 순차적으로 다루는 데에 아주 제격

<br>

### 시간 복잡도
1. 탐색(Search) <br>
   _**O(n)**_ <br>
   > 탐색 작업은 최악의 경우 리스트의 끝까지 모든 노드를 탐색 해야 하므로 <br>
   > _**선형 시간 복잡도**_ 를 가짐

3. 삽입(Insert) <br>
   (1) 특정 위치를 알고 있는 경우 - _**O(1)**_ <br>
   (2) 특정 위치를 찾기 위해 탐색이 필요한 경우 - _**O(n)**_ <br>
   > 삽입 작업 자체는 _**상수 시간 복잡도**_ 를 가지지만, <br>
   > 삽입 위치를 찾기 위한 탐색 시간 복잡도는 _**O(n)**_

5. 삭제(Delete) <br>
   (1) 특정 위치를 알고 있는 경우 - _**O(1)**_ <br>
   (2) 특정 위치를 찾기 위해 탐색이 필요한 경우 - _**O(n)**_ <br>
   > 삭제 작업 자체는 _**상수 시간 복잡도**_ 를 가지지만, <br>
   > 삭제할 노드를 찾기 위한 탐색 시간 복잡도는 _**O(n)**_ <br>

6. 접근(Access) <br>
   _**O(n)**_ <br>
   > 인덱스를 통한 직접 접근은 <br>
   > 리스트의 _**시작부터 해당 위치까지 순차적으로 이동**_ 해야 하므로 <br>
   > _**선형 시간 복잡도**_ 를 가짐 <br>

<br>

### 요약
* 요약하자면 링크드 리스트는 삽입과 삭제 작업에서는 효율적이지만, <br>탐색과 접근 작업에서는 배열보다 비효율적
* 링크드 리스트의 장점은 동적 메모리 할당과 크기 조정의 유연성에 있으며, <br>단점은 탐색과 접근의 상대적 비효율성임